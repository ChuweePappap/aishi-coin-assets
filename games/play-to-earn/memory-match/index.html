<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Memory Match - Play to Earn</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto,
          Oxygen, Ubuntu, Cantarell, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        padding: 20px;
        overflow-x: hidden;
      }

      .game-container {
        background: white;
        border-radius: 20px;
        padding: 30px;
        max-width: 600px;
        width: 100%;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
      }

      .header {
        text-align: center;
        margin-bottom: 25px;
        position: relative;
      }

      .potential-reward-display {
        background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
        padding: 12px 20px;
        border-radius: 12px;
        text-align: center;
        margin-bottom: 20px;
        box-shadow: 0 4px 6px rgba(251, 191, 36, 0.3);
        animation: pulse 2s ease-in-out infinite;
      }

      .potential-label {
        font-size: 12px;
        color: rgba(255, 255, 255, 0.9);
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .potential-value {
        font-size: 28px;
        font-weight: 700;
        color: white;
        margin-top: 4px;
      }

      @keyframes pulse {
        0%,
        100% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.02);
        }
      }

      h1 {
        color: #667eea;
        font-size: 32px;
        margin-bottom: 10px;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 10px;
      }

      .subtitle {
        color: #6b7280;
        font-size: 14px;
        margin-bottom: 15px;
      }

      .stats {
        display: flex;
        justify-content: space-around;
        gap: 15px;
        margin-bottom: 25px;
      }

      .stat-item {
        background: linear-gradient(135deg, #f3f4f6 0%, #e5e7eb 100%);
        padding: 12px 20px;
        border-radius: 12px;
        text-align: center;
        flex: 1;
      }

      .stat-label {
        font-size: 12px;
        color: #6b7280;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .stat-value {
        font-size: 24px;
        font-weight: 700;
        color: #1f2937;
        margin-top: 5px;
      }

      .game-board {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 10px;
        margin-bottom: 25px;
      }

      .card {
        aspect-ratio: 1;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        border-radius: 12px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 36px;
        cursor: pointer;
        transition: all 0.3s ease;
        transform-style: preserve-3d;
        position: relative;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      }

      .card:hover:not(.flipped):not(.matched) {
        transform: scale(1.05);
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
      }

      .card.flipped {
        background: white;
        border: 3px solid #667eea;
      }

      .card.matched {
        background: linear-gradient(135deg, #10b981 0%, #059669 100%);
        animation: matchAnimation 0.6s ease;
      }

      .card.wrong {
        animation: wrongAnimation 0.5s ease;
      }

      .card-back {
        position: absolute;
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        backface-visibility: hidden;
      }

      .card-front {
        display: none;
      }

      .card.flipped .card-back {
        display: none;
      }

      .card.flipped .card-front,
      .card.matched .card-front {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 100%;
        height: 100%;
      }

      @keyframes matchAnimation {
        0%,
        100% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.1);
        }
      }

      @keyframes wrongAnimation {
        0%,
        100% {
          transform: translateX(0);
        }
        25% {
          transform: translateX(-10px);
        }
        75% {
          transform: translateX(10px);
        }
      }

      .buttons {
        display: flex;
        gap: 10px;
        justify-content: center;
      }

      .btn {
        padding: 12px 24px;
        border: none;
        border-radius: 10px;
        font-size: 16px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
        flex: 1;
        max-width: 200px;
      }

      .btn-primary {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
      }

      .btn-primary:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
      }

      .btn-secondary {
        background: #f3f4f6;
        color: #1f2937;
      }

      .btn-secondary:hover {
        background: #e5e7eb;
      }

      .modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.7);
        z-index: 1000;
        align-items: center;
        justify-content: center;
        padding: 20px;
      }

      .modal.active {
        display: flex;
        animation: fadeIn 0.3s ease;
      }

      .modal-content {
        background: white;
        border-radius: 20px;
        padding: 40px;
        text-align: center;
        max-width: 400px;
        width: 100%;
        animation: slideUp 0.4s ease;
      }

      .modal-icon {
        font-size: 80px;
        margin-bottom: 20px;
      }

      .modal-title {
        font-size: 28px;
        font-weight: 700;
        color: #1f2937;
        margin-bottom: 15px;
      }

      .modal-text {
        font-size: 16px;
        color: #6b7280;
        margin-bottom: 25px;
        line-height: 1.5;
      }

      .reward-box {
        background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
        padding: 20px;
        border-radius: 12px;
        margin-bottom: 25px;
      }

      .reward-text {
        color: white;
        font-size: 14px;
        font-weight: 600;
        margin-bottom: 5px;
      }

      .reward-amount {
        color: white;
        font-size: 32px;
        font-weight: 700;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
        }
        to {
          opacity: 1;
        }
      }

      @keyframes slideUp {
        from {
          transform: translateY(50px);
          opacity: 0;
        }
        to {
          transform: translateY(0);
          opacity: 1;
        }
      }

      @media (max-width: 600px) {
        .game-container {
          padding: 20px;
        }

        h1 {
          font-size: 24px;
        }

        .card {
          font-size: 28px;
        }

        .stat-value {
          font-size: 20px;
        }
      }
    </style>
  </head>
  <body>
    <div class="game-container">
      <div class="header">
        <h1>
          <span>üé¥</span>
          Memory Match
          <span>üé¥</span>
        </h1>
        <p class="subtitle">Match all pairs to earn rewards!</p>
      </div>

      <div
        class="potential-reward-display"
        id="potentialDisplay"
        style="display: none"
      >
        <div class="potential-label">Max Possible Reward:</div>
        <div class="potential-value">
          <span id="potentialReward">0</span> AIShi
        </div>
      </div>

      <div class="stats" id="statsDisplay" style="display: none">
        <div class="stat-item">
          <div class="stat-label">Moves</div>
          <div class="stat-value" id="moves">0</div>
        </div>
        <div class="stat-item">
          <div class="stat-label">Time</div>
          <div class="stat-value" id="timer">0:00</div>
        </div>
        <div class="stat-item">
          <div class="stat-label">Reward (AIShi)</div>
          <div class="stat-value" id="score">0</div>
        </div>
      </div>

      <div class="game-board" id="gameBoard"></div>

      <div class="buttons">
        <button
          class="btn btn-primary"
          id="startBtn"
          onclick="playButtonClickSound(); startGame()"
        >
          Start Game
        </button>
      </div>
    </div>

    <!-- Win Modal -->
    <div class="modal" id="winModal">
      <div class="modal-content">
        <div class="modal-icon">üéâ</div>
        <h2 class="modal-title">Congratulations!</h2>
        <p class="modal-text">
          You matched all pairs!<br />
          Time: <strong id="finalTime"></strong><br />
          Moves: <strong id="finalMoves"></strong>
        </p>
        <div
          style="
            background: #f3f4f6;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            text-align: left;
          "
        >
          <div
            style="
              font-size: 14px;
              font-weight: 600;
              color: #667eea;
              margin-bottom: 8px;
            "
          >
            Reward Breakdown:
          </div>
          <div
            style="font-size: 13px; color: #1f2937; margin-bottom: 4px"
            id="breakdownMoves"
          >
            8 moves: 500 AIShi
          </div>
          <div style="font-size: 13px; color: #1f2937" id="breakdownTime">
            45 seconds: +50 AIShi
          </div>
        </div>
        <div class="reward-box">
          <div class="reward-text">Total Reward</div>
          <div class="reward-amount" id="rewardAmount">+0 AIShi</div>
        </div>

        <!-- Submission Status -->
        <div id="submissionStatus" style="display: none; margin-bottom: 15px">
          <div
            id="submissionMessage"
            style="font-size: 14px; color: #6b7280; margin-bottom: 10px"
          ></div>
        </div>

        <!-- Action Buttons -->
        <div class="buttons">
          <button
            id="claimBtn"
            class="btn btn-primary"
            onclick="playButtonClickSound(); handleClaim()"
            style="display: none"
          >
            Submit
          </button>
          <button
            id="tryAgainBtn"
            class="btn btn-secondary"
            onclick="playButtonClickSound(); playAgain()"
            style="display: none"
          >
            Try Again
          </button>
        </div>
      </div>
    </div>

    <!-- Info Modal - Removed (now shown in main app before game starts) -->

    <script>
      const emojis = [
        'üéÆ',
        'üéØ',
        'üé≤',
        'üé™',
        'üé®',
        'üé≠',
        'üé∏',
        'üé∫',
        'üéπ',
        'üéº',
        'üèÜ',
        'üíé',
        '‚≠ê',
        'üåü',
        '‚ú®',
        'üî•',
        'üí∞',
        'üéÅ',
        'üèÖ',
        'üëë',
      ]

      let cards = []
      let flippedCards = []
      let matchedPairs = 0
      let moves = 0
      let score = 0
      let timer = 0
      let timerInterval = null
      let gameStarted = false
      let currentDifficulty = 'hard'
      let pairCount = 8
      let submittedScore = false
      let blockchainSubmitted = false // Track if score was submitted to blockchain
      let nullifierHash = null
      let sessionId = null
      let rewardAmount = 0
      let backendSignature = null
      let GAME_FEE = 5 // Default, will be overridden by parent

      // ========================================
      // üîä SYNTHESIZED SOUND EFFECTS
      // ========================================
      let audioContext = null

      const getAudioContext = () => {
        if (!audioContext) {
          const AudioContextClass =
            window.AudioContext || window.webkitAudioContext
          audioContext = new AudioContextClass()
        }

        // Resume if suspended
        if (audioContext.state === 'suspended') {
          audioContext.resume().catch((err) => {
            console.log('AudioContext resume failed:', err)
          })
        }

        return audioContext
      }

      // Play match success sound - cheerful ascending tones
      const playMatchSound = (volume = 0.6) => {
        try {
          const ctx = getAudioContext()
          const now = ctx.currentTime

          // Pleasant ascending arpeggio (C major chord)
          const frequencies = [523.25, 659.25, 783.99] // C, E, G notes

          frequencies.forEach((freq, index) => {
            const oscillator = ctx.createOscillator()
            const gainNode = ctx.createGain()

            oscillator.connect(gainNode)
            gainNode.connect(ctx.destination)

            oscillator.type = 'sine'
            oscillator.frequency.setValueAtTime(freq, now)

            const startTime = now + index * 0.08
            const duration = 0.3

            gainNode.gain.setValueAtTime(0, startTime)
            gainNode.gain.linearRampToValueAtTime(
              volume * 0.25,
              startTime + 0.02
            )
            gainNode.gain.exponentialRampToValueAtTime(
              0.001,
              startTime + duration
            )

            oscillator.start(startTime)
            oscillator.stop(startTime + duration)
          })
        } catch (error) {
          console.log('Audio synthesis failed:', error)
        }
      }

      // Play mismatch sound - subtle descending tone
      const playMismatchSound = (volume = 0.4) => {
        try {
          const ctx = getAudioContext()
          const now = ctx.currentTime

          const oscillator = ctx.createOscillator()
          const gainNode = ctx.createGain()
          const filter = ctx.createBiquadFilter()

          oscillator.connect(filter)
          filter.connect(gainNode)
          gainNode.connect(ctx.destination)

          oscillator.type = 'sine'
          oscillator.frequency.setValueAtTime(400, now)
          oscillator.frequency.exponentialRampToValueAtTime(300, now + 0.15)

          filter.type = 'lowpass'
          filter.frequency.setValueAtTime(800, now)
          filter.Q.setValueAtTime(1, now)

          gainNode.gain.setValueAtTime(0, now)
          gainNode.gain.linearRampToValueAtTime(volume * 0.2, now + 0.02)
          gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.2)

          oscillator.start(now)
          oscillator.stop(now + 0.2)
        } catch (error) {
          console.log('Audio synthesis failed:', error)
        }
      }

      // Play button click sound
      const playButtonClickSound = (volume = 0.4) => {
        try {
          const ctx = getAudioContext()
          const now = ctx.currentTime

          const oscillator = ctx.createOscillator()
          const gainNode = ctx.createGain()
          const filter = ctx.createBiquadFilter()

          oscillator.connect(filter)
          filter.connect(gainNode)
          gainNode.connect(ctx.destination)

          oscillator.type = 'sine'
          oscillator.frequency.setValueAtTime(1200, now)
          oscillator.frequency.exponentialRampToValueAtTime(800, now + 0.04)

          filter.type = 'bandpass'
          filter.frequency.setValueAtTime(1000, now)
          filter.Q.setValueAtTime(2, now)

          gainNode.gain.setValueAtTime(0, now)
          gainNode.gain.linearRampToValueAtTime(volume * 0.3, now + 0.005)
          gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.05)

          oscillator.start(now)
          oscillator.stop(now + 0.05)
        } catch (error) {
          console.log('Audio synthesis failed:', error)
        }
      }

      let gameTranslations = {
        congratulations: 'Congratulations!',
        betterLuckNextTime: 'Better luck next time',
        rewardClaimedSuccessfully: '‚úÖ Reward claimed successfully!',
        gotIt: 'Got it',
        submit: 'Submit',
        tryAgain: 'Try Again',
      }

      // Get nullifierHash from parent window
      window.addEventListener('message', (event) => {
        console.log('üîî Message received in game:', event.data.type)

        if (event.data.type === 'NULLIFIER_HASH') {
          nullifierHash = event.data.nullifierHash
          console.log('Received nullifierHash from parent:', nullifierHash)

          // Receive game fee from parent if available
          if (event.data.gameFee) {
            GAME_FEE = event.data.gameFee
            console.log('Received gameFee from parent:', GAME_FEE)
          }

          // Also receive translations if available
          if (event.data.translations) {
            gameTranslations = event.data.translations
            console.log('Received translations from parent:', gameTranslations)

            // Update button text with translations
            updateButtonTranslations()
          }
        } else if (event.data.type === 'CLAIM_SUCCESS') {
          // Blockchain submission successful - update the congratulations modal
          console.log('=== CLAIM_SUCCESS received ===')
          console.log('Blockchain submission successful')
          console.log('Current blockchainSubmitted flag:', blockchainSubmitted)

          // Mark as submitted to blockchain
          blockchainSubmitted = true
          console.log('Set blockchainSubmitted to:', blockchainSubmitted)

          // Update submission status to show success message
          showSubmissionStatus(
            '‚úÖ Score successfully submitted! Go to main page to claim your reward.',
            'success'
          )

          // Change Submit button to "Got it"
          const claimBtn = document.getElementById('claimBtn')
          console.log('claimBtn element:', claimBtn)
          if (claimBtn) {
            const gotItText = gameTranslations.gotIt || 'Got it'
            console.log('Setting button text to:', gotItText)
            claimBtn.textContent = gotItText
            claimBtn.disabled = false
            claimBtn.style.display = 'block'
            console.log(
              'Button updated - text:',
              claimBtn.textContent,
              'disabled:',
              claimBtn.disabled
            )
          } else {
            console.error('‚ùå claimBtn not found!')
          }
        }
      })

      // Request nullifierHash on load
      if (window.parent !== window) {
        window.parent.postMessage({ type: 'REQUEST_NULLIFIER_HASH' }, '*')
      }

      // Update button text with current translations
      function updateButtonTranslations() {
        const claimBtn = document.getElementById('claimBtn')
        const tryAgainBtn = document.getElementById('tryAgainBtn')

        if (claimBtn) {
          claimBtn.textContent = gameTranslations.submit || 'Submit'
        }
        if (tryAgainBtn) {
          tryAgainBtn.textContent = gameTranslations.tryAgain || 'Try Again'
        }
      }

      const difficultySettings = {
        hard: { pairs: 8, gridCols: 4, reward: 20 },
      }

      function createCards() {
        const selectedEmojis = emojis.slice(0, pairCount)
        const cardEmojis = [...selectedEmojis, ...selectedEmojis]

        // Shuffle array
        for (let i = cardEmojis.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1))
          ;[cardEmojis[i], cardEmojis[j]] = [cardEmojis[j], cardEmojis[i]]
        }

        return cardEmojis
      }

      function renderBoard() {
        const board = document.getElementById('gameBoard')
        board.innerHTML = ''
        board.style.gridTemplateColumns = `repeat(${difficultySettings[currentDifficulty].gridCols}, 1fr)`

        cards.forEach((emoji, index) => {
          const card = document.createElement('div')
          card.className = 'card'
          card.dataset.index = index
          card.dataset.emoji = emoji
          card.innerHTML = `
                    <div class="card-back">‚ùì</div>
                    <div class="card-front">${emoji}</div>
                `
          card.addEventListener('click', () => flipCard(card))
          board.appendChild(card)
        })
      }

      function flipCard(card) {
        if (!gameStarted) return
        if (
          card.classList.contains('flipped') ||
          card.classList.contains('matched')
        )
          return
        if (flippedCards.length >= 2) return

        // Play subtle card flip sound
        playButtonClickSound(0.3)

        card.classList.add('flipped')
        flippedCards.push(card)

        if (flippedCards.length === 2) {
          moves++
          document.getElementById('moves').textContent = moves
          checkMatch()
        }
      }

      function checkMatch() {
        const [card1, card2] = flippedCards
        const emoji1 = card1.dataset.emoji
        const emoji2 = card2.dataset.emoji

        if (emoji1 === emoji2) {
          // Match found! Play success sound
          playMatchSound()

          setTimeout(() => {
            card1.classList.add('matched')
            card2.classList.add('matched')
            card1.classList.remove('flipped')
            card2.classList.remove('flipped')
            flippedCards = []
            matchedPairs++

            // Update potential reward after matchedPairs is updated
            updatePotentialReward()

            // Update score - New performance-based scoring
            // Perfect game: 8 moves (minimum possible)
            // Max score: 250 points for 8 moves under 60 seconds
            // 0 points for 30+ moves

            if (matchedPairs === pairCount) {
              // Calculate final score when game is complete
              calculateFinalScore()
            }

            // Check if game is won
            if (matchedPairs === pairCount) {
              endGame()
            }
          }, 300)
        } else {
          // No match - Play mismatch sound
          playMismatchSound()

          setTimeout(() => {
            card1.classList.add('wrong')
            card2.classList.add('wrong')

            setTimeout(() => {
              card1.classList.remove('flipped', 'wrong')
              card2.classList.remove('flipped', 'wrong')
              flippedCards = []

              // Update potential reward after failed match
              updatePotentialReward()
            }, 500)
          }, 800)
        }
      }

      function startTimer() {
        timerInterval = setInterval(() => {
          timer++
          const minutes = Math.floor(timer / 60)
          const seconds = timer % 60
          document.getElementById('timer').textContent = `${minutes}:${seconds
            .toString()
            .padStart(2, '0')}`
          updatePotentialReward()
        }, 1000)
      }

      function calculateFinalScore() {
        // UPDATED SCORING SYSTEM
        // Perfect game: 8 moves (minimum possible for 8 pairs)
        // Score IS the AIShi reward directly
        // Game fee is user-selected (5, 10, 15, 20, or 30 AIShi)
        // Using dynamic GAME_FEE variable
        // Examples with 5 AIShi fee:
        // - 8 moves = 5 * 200 = 1000 AIShi
        // - 9 moves = 5 * 100 = 500 AIShi
        // - 10 moves = 5 * 50 = 250 AIShi
        // - 11 moves = 5 * 40 = 200 AIShi
        // - 12 moves = 5 * 30 = 150 AIShi
        // - 13 moves = 5 * 20 = 100 AIShi
        // - 14 moves = 5 * 10 = 50 AIShi
        // - 15-20 moves = 5 * 2 = 10 AIShi
        // - 20+ moves = 0 AIShi

        const MAX_MOVES_FOR_REWARD = 20

        // If 20 or more moves, no reward
        if (moves >= MAX_MOVES_FOR_REWARD) {
          score = 0
          document.getElementById('score').textContent = score
          return
        }

        // Calculate base move score based on exact tiers
        let moveScore = 0
        if (moves === 8) {
          moveScore = GAME_FEE * 200 // 1000
        } else if (moves === 9) {
          moveScore = GAME_FEE * 100 // 500
        } else if (moves === 10) {
          moveScore = GAME_FEE * 50 // 250
        } else if (moves === 11) {
          moveScore = GAME_FEE * 40 // 200
        } else if (moves >= 12 && moves <= 14) {
          moveScore = GAME_FEE * 10 // 50
        } else if (moves < 20) {
          // 15-19 moves
          moveScore = GAME_FEE * 2 // 10
        } else {
          moveScore = 0
        }

        // Time bonus (0 to fee*2 AIShi)
        const FAST_TIME = 30 // 30 seconds
        const MAX_TIME_BONUS = GAME_FEE * 2 // Max bonus is fee * 2

        let timeBonus = 0
        if (timer < FAST_TIME) {
          timeBonus = MAX_TIME_BONUS // Full bonus for under 30 seconds
        }
        // 30 seconds or more = 0 bonus

        // Total score = move score + time bonus
        score = moveScore + timeBonus
        document.getElementById('score').textContent = score
      }

      function calculatePotentialReward() {
        // Calculate the maximum possible reward based on current moves
        console.log(
          'calculatePotentialReward called - moves:',
          moves,
          'timer:',
          timer,
          'matchedPairs:',
          matchedPairs
        )
        if (moves >= 20) return 0

        // Calculate minimum possible final moves
        // We need 8 total matches. We've already made some moves and matched some pairs.
        // Minimum moves to finish = current moves + remaining pairs to match
        const remainingPairs = pairCount - matchedPairs
        const minPossibleMoves = moves + remainingPairs

        console.log(
          'remainingPairs:',
          remainingPairs,
          'minPossibleMoves:',
          minPossibleMoves
        )

        // Use dynamic GAME_FEE variable
        let baseReward = 0
        if (minPossibleMoves === 8) {
          baseReward = GAME_FEE * 200 // 1000
        } else if (minPossibleMoves === 9) {
          baseReward = GAME_FEE * 100 // 500
        } else if (minPossibleMoves === 10) {
          baseReward = GAME_FEE * 50 // 250
        } else if (minPossibleMoves === 11) {
          baseReward = GAME_FEE * 40 // 200
        } else if (minPossibleMoves === 12) {
          baseReward = GAME_FEE * 30 // 150
        } else if (minPossibleMoves === 13) {
          baseReward = GAME_FEE * 20 // 100
        } else if (minPossibleMoves === 14) {
          baseReward = GAME_FEE * 10 // 50
        } else if (minPossibleMoves < 20) {
          // 15-19 moves
          baseReward = GAME_FEE * 2 // 10
        } else {
          baseReward = 0
        }
        console.log('baseReward:', baseReward)

        // Add max time bonus based on current time (0 to fee*2 AIShi)
        // Show the maximum they can still get
        const FAST_TIME = 30
        const MAX_TIME_BONUS = GAME_FEE * 2 // Max bonus is fee * 2
        let maxTimeBonus = 0
        if (timer < FAST_TIME) {
          maxTimeBonus = MAX_TIME_BONUS // Still can get full bonus
        }
        // 30 seconds or more = 0 bonus
        console.log('maxTimeBonus:', maxTimeBonus)

        const total = baseReward + maxTimeBonus
        console.log('total potential:', total)
        return total
      }

      function updatePotentialReward() {
        if (!gameStarted) return
        const potential = calculatePotentialReward()
        const potentialEl = document.getElementById('potentialReward')
        if (potentialEl) {
          potentialEl.textContent = potential
        }
      }

      function startGame() {
        gameStarted = true
        cards = createCards()
        matchedPairs = 0
        moves = 0
        score = 0
        timer = 0
        flippedCards = []

        document.getElementById('moves').textContent = '0'
        document.getElementById('timer').textContent = '0:00'
        document.getElementById('score').textContent = '0'
        document.getElementById('startBtn').style.display = 'none'

        // Show stats display
        document.getElementById('statsDisplay').style.display = 'flex'

        // Show potential reward display with max reward (8 moves + 50 time bonus)
        const maxReward = GAME_FEE * 200 + 50
        document.getElementById('potentialDisplay').style.display = 'block'
        document.getElementById('potentialReward').textContent = maxReward

        renderBoard()
        startTimer()
      }

      function resetGame() {
        gameStarted = false
        clearInterval(timerInterval)

        document.getElementById('startBtn').style.display = 'block'
        document.getElementById('gameBoard').innerHTML = ''
        document.getElementById('moves').textContent = '0'
        document.getElementById('timer').textContent = '0:00'
        document.getElementById('score').textContent = '0'

        // Hide stats display
        document.getElementById('statsDisplay').style.display = 'none'

        // Hide potential reward display
        document.getElementById('potentialDisplay').style.display = 'none'
      }

      function endGame() {
        gameStarted = false
        clearInterval(timerInterval)

        const minutes = Math.floor(timer / 60)
        const seconds = timer % 60
        const timeString = `${minutes}:${seconds.toString().padStart(2, '0')}`

        document.getElementById('finalTime').textContent = timeString
        document.getElementById('finalMoves').textContent = moves

        // Calculate breakdown for display
        // Recalculate move score using dynamic GAME_FEE
        let moveScore = 0
        if (moves === 8) {
          moveScore = GAME_FEE * 200 // 1000
        } else if (moves === 9) {
          moveScore = GAME_FEE * 100 // 500
        } else if (moves === 10) {
          moveScore = GAME_FEE * 50 // 250
        } else if (moves === 11) {
          moveScore = GAME_FEE * 40 // 200
        } else if (moves >= 12 && moves <= 14) {
          moveScore = GAME_FEE * 10 // 50
        } else if (moves < 20) {
          // 15-19 moves
          moveScore = GAME_FEE * 2 // 10
        } else {
          moveScore = 0
        }

        // Recalculate time bonus
        const FAST_TIME = 30
        const MAX_TIME_BONUS = GAME_FEE * 2 // Max bonus is fee * 2
        let timeBonus = 0
        if (timer < FAST_TIME) {
          timeBonus = MAX_TIME_BONUS
        }
        // 30 seconds or more = 0 bonus

        // Update breakdown display
        document.getElementById(
          'breakdownMoves'
        ).textContent = `${moves} moves: ${moveScore} AIShi`
        document.getElementById(
          'breakdownTime'
        ).textContent = `${timer} seconds: +${timeBonus} AIShi`

        const reward = score
        document.getElementById('rewardAmount').textContent = `+${reward} AIShi`

        // Update modal title and icon based on reward
        const modalIcon = document.querySelector('#winModal .modal-icon')
        const modalTitle = document.querySelector('#winModal .modal-title')
        if (reward === 0) {
          modalIcon.textContent = 'üòî'
          modalTitle.textContent = gameTranslations.betterLuckNextTime
          // Show Try Again button for 0 reward, hide Submit button
          const tryAgainBtn = document.getElementById('tryAgainBtn')
          if (tryAgainBtn) {
            tryAgainBtn.textContent = gameTranslations.tryAgain || 'Try Again'
            tryAgainBtn.style.display = 'block'
          }
          document.getElementById('claimBtn').style.display = 'none'
        } else {
          modalIcon.textContent = 'üéâ'
          modalTitle.textContent = gameTranslations.congratulations
          // Hide Try Again button for rewards > 0
          document.getElementById('tryAgainBtn').style.display = 'none'

          // Update Submit button text
          const claimBtn = document.getElementById('claimBtn')
          if (claimBtn) {
            claimBtn.textContent = gameTranslations.submit || 'Submit'
          }
        }

        document.getElementById('winModal').classList.add('active')

        // Hide potential reward display when game ends
        document.getElementById('potentialDisplay').style.display = 'none'

        // Auto-submit score
        if (reward > 0) {
          submitScore(reward)
        } else {
          showSubmissionStatus('No reward to claim (score is 0)', 'error')
        }
      }

      // Submit score to backend
      async function submitScore(finalScore) {
        console.log('Attempting to submit score...')
        console.log('Nullifier hash:', nullifierHash)
        console.log('Already submitted:', submittedScore)

        if (!nullifierHash) {
          console.error('No nullifier hash available!')
          showSubmissionStatus(
            '‚ùå Error: User not authenticated. Please refresh and sign in again.',
            'error'
          )
          // Try to request it again
          if (window.parent !== window) {
            console.log('Requesting nullifier hash from parent...')
            window.parent.postMessage({ type: 'REQUEST_NULLIFIER_HASH' }, '*')
          }
          return
        }

        if (submittedScore) {
          showSubmissionStatus('‚ö†Ô∏è Score already submitted', 'warning')
          return
        }

        showSubmissionStatus('üì§ Submitting score...', 'loading')

        try {
          const response = await fetch('/api/game/submit-score', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              nullifierHash: nullifierHash,
              score: finalScore,
              gameName: 'Memory Match',
            }),
          })

          const data = await response.json()

          if (data.success) {
            submittedScore = true
            sessionId = data.data.sessionId
            rewardAmount = data.data.amount
            backendSignature = data.data.signature

            showSubmissionStatus(
              '‚úÖ Score ready! Click Submit to save to blockchain.',
              'success'
            )

            // Update button text to "Submit" and show it
            const claimBtn = document.getElementById('claimBtn')
            if (claimBtn) {
              claimBtn.textContent = gameTranslations.submit || 'Submit'
              claimBtn.style.display = 'block'
              claimBtn.disabled = false
              console.log(
                'Submit button shown with text:',
                claimBtn.textContent
              )
            }
          } else {
            showSubmissionStatus(`‚ùå Error: ${data.error}`, 'error')
          }
        } catch (error) {
          console.error('Error submitting score:', error)
          showSubmissionStatus(
            '‚ùå Failed to submit score. Please try again.',
            'error'
          )
        }
      }

      // Show submission status message
      function showSubmissionStatus(message, type) {
        const statusDiv = document.getElementById('submissionStatus')
        const messageDiv = document.getElementById('submissionMessage')

        messageDiv.textContent = message
        statusDiv.style.display = 'block'

        // Color based on type
        if (type === 'success') {
          messageDiv.style.color = '#10b981'
        } else if (type === 'error') {
          messageDiv.style.color = '#ef4444'
        } else if (type === 'warning') {
          messageDiv.style.color = '#f59e0b'
        } else {
          messageDiv.style.color = '#6b7280'
        }
      }

      // Handle claim button click
      async function handleClaim() {
        const claimBtn = document.getElementById('claimBtn')

        // Check if already submitted to blockchain
        if (blockchainSubmitted) {
          // Close game and return to main page
          if (window.parent !== window) {
            window.parent.postMessage({ type: 'CLOSE_GAME' }, '*')
          } else {
            // Fallback if not in iframe - try to go to home page
            window.location.href = '/'
          }
          return
        }

        // Otherwise, submit to blockchain first
        if (!submittedScore || !sessionId || !backendSignature) {
          alert('Please play the game and submit your score first!')
          return
        }

        // Disable button during submission
        if (claimBtn) {
          claimBtn.disabled = true
          claimBtn.textContent = 'Submitting...'
        }

        showSubmissionStatus('üì§ Submitting to blockchain...', 'loading')

        // Send message to parent window to trigger claim with World ID
        if (window.parent !== window) {
          window.parent.postMessage(
            {
              type: 'CLAIM_REWARD_IMMEDIATE',
              nullifierHash: nullifierHash,
              amount: rewardAmount,
              sessionId: sessionId,
              signature: backendSignature,
              gameName: 'Memory Match',
            },
            '*'
          )
        } else {
          alert('This game must be played within the app to claim rewards.')
          if (claimBtn) {
            claimBtn.disabled = false
            claimBtn.textContent = gameTranslations.submit || 'Submit'
          }
        }
      }

      function playAgain() {
        document.getElementById('winModal').classList.remove('active')
        submittedScore = false
        blockchainSubmitted = false
        sessionId = null
        rewardAmount = 0
        backendSignature = null
        document.getElementById('claimBtn').style.display = 'none'
        document.getElementById('tryAgainBtn').style.display = 'none'
        document.getElementById('submissionStatus').style.display = 'none'

        // Close game and return to main page
        if (window.parent !== window) {
          window.parent.postMessage({ type: 'CLOSE_GAME' }, '*')
        } else {
          // Fallback if not in iframe
          resetGame()
        }
      }

      // Prevent closing modal when clicking outside
      document
        .getElementById('winModal')
        .addEventListener('click', function (e) {
          if (e.target === this) {
            // Don't allow closing by clicking outside - user must use buttons
            return
          }
        })

      // Info modal removed - now shown in main app before game starts
    </script>
  </body>
</html>
